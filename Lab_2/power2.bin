; Purpose: Figure out if a number (positive 2's complement integer) is a power of 2 => only one 1 bit. 
; Code starts @ x3000
; Input: positive two's complement number stored in x3050 (doesn't handle 0 case properly)
; Output: 1 @ x3051 = power of two; 0 @ x3051 = not a power of two
;

0011 0000 0000 0000     ;starting address of x3000

0101 010 010 1 00000    ;AND, DR=R2, SR=R2, #0    // R2<-0
1010 000 000000111      ;LDI, DR=R0, offset=#7    // R0<-M[M[x3009]] == R0<-M[x3050] == R0<-(#)
0000 010 000000100      ;BR, NZP=010, off=#4      // If R0 = 0, store right away (not a power of 2)
0001 001 000 1 11111    ;ADD, DR=R1, SR=R0, #31   // R1<-R0+#31 
0101 000 000 0 00 001   ;AND, DR=R0, SR=R0, SR=R1 // R0<-R0 AND R1
0000 101 000000001      ;BR, NZP=101, off=#1      // If R0 not 0, skip next line (not power of 2)
0001 010 010 1 00001    ;ADD, DR=R2, SR=R2, #1    // R2<-R2+#1 == R2<-1 (is power of 2)
1011 010 000000010      ;STI, SR=R2, off=#2       // M[M[x300A]]<-R2 == M[x3051]<-R2
1111 0000 0010 0101     ;TRAP, x25                // HALT

;hardcoded values
0011 0000 0101 0000     ;Address x3009: value x3050
0011 0000 0101 0001     ;Address x300A: value x3051